<!DOCTYPE html>
<html onclick="pageClick()" onkeydown="keyDown()">
<head>
	<!-- Google Tag Manager -->
	<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});
        var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
        j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-MH9TLBLK');</script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9HK482ET14"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9HK482ET14');
    </script>
    <!-- Google AdSense  -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0549784498739741" crossorigin="anonymous"></script>
    <!-- End Google -->

    <title>Flip.IT</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://ico.xink.in/pog_arrow_white.png" rel="icon" />
</head>
<body onresize="resize()">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MH9TLBLK" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

<style>
    body {
        margin-top:0px;
        margin-left:0px;
        overflow-x:hidden;
    }
    label {
        user-select:none;
    }
    #myCanvas {
        border:0px solid; 
        position:relative; 
        left:10px; 
        top:50px;
    }
    #objective {
        margin-top:10px;
        padding:5px;
        background-color:white;
    }
    input[type="checkbox"] {
        width:18px;
        height:18px;
    }
    [title]:hover::after {
        content: attr(title);
        background-color:green;
    }
    .statusLine {
        position:relative;
        top:20px;
        left:20px;
        font-size:18px;
    }
    .brnodisplay {display:none;}
    .button {
        width:100px;
    }
    .menuicon {
        position:absolute;
        display:block;
        right:0px;
        top:20px;
        padding:5px;
        font-size:17px;
    }
    .menuicon:hover {
        background-color:#ddd;
        color:black;
    }
    .menuContent {
        position:absolute;
        display:none;
        width:150px;
        right:0;
        padding:5px;
        overflow-y:auto;
        max-height:98vh;
        z-index:100;
        background:gray;
    }
    .menuContent h1 {
        font-size:22px;
        text-align:center;
        text-decoration:underline;
        text-underline-position:under;
    }
    .menuLabel {font-weight:bold;}
    .menuLabel:after {content:':'}
    .menuContent table {padding:10px;}
    .menuContent td {padding:10px;}
    .menuData {
        font-weight:normal;
        color:lightcyan;
    }
    .menuItem {
        width:100%;
        height:20px;
        margin:3px auto;
    }
    .menuText {
        color:white;
    }
    #help {
        width:260px;
        padding-left:20px;
        padding-right:20px
    }
    .targetImage {
        width:190px;
        height:190px;
        margin-left:20px;  /*  (help,width - 190 - 20) / 2    */
    }
    #puzzledate {
        position:absolute;
        left:332px;
        top:47px;
        font-weight:bold;
        font-size:12px;
        overflow:hidden;
        user-select:none; 
    }
    .bottomAdbar {
        position:absolute;
        bottom:0;
        left:10px;
        width:100%;
        height:100px;
        padding-top:10px;
    }
    .noLandscape {
        display:none;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        padding-top:100px;
        background-color:white;
        text-align: center;
        z-index:2147483647;
    }
    @media only screen and (max-height: 360px) and (orientation:landscape) {
        .noLandscape {display:block;}
    }
    @media only screen and (max-width: 768px), only screen and (max-height: 790px) {
        /* For mobile phones: */
        #undo {
            display:none;
        }
        #puzzledate {
            left:227px;
            font-size:16px;
            font-weight:normal;
        }
        .menuContent {
            max-height:85vh;
        }
        .menuItem {height:25px;}
        #help {
            width:330px;
            padding-left:10px;
            padding-right:10px
        }
        .targetImage {
            padding-left:45px;  /*  (help,width - 190 - 20) / 2    */
        }
    }
    @media only screen and (max-width: 507px), only screen and (max-height: 682px) {
        .brnodisplay {display:block;}
        #puzzledate {
            left:10px;
            top:79px;
            font-weight:normal;
        }
        .lblPuzzleNo {
            left:10px !important;
            top:25px;
        }
        #puzzleNo{
            left:18px !important;
            top:25px;
        }
    }
    @media only screen and (max-width: 400px), only screen and (max-height: 572px) {
        #help {width:unset;}
        #stats {width:unset !important;}
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<div id="topDiv" style="width:100%">
<div class="noLandscape">
    <p>To enable this app to fit your screen<br/>
        <b>please rotate your device.</b>
    </p>
</div>
<div style="position:absolute; top:0px; left:0px;">
    <label class="statusLine" style="font-weight:bold; left:10px;">Moves: </label><label id="moves" class="statusLine" style="left:10px;"></label>
    <button id="reset" class="statusLine button">Reset</button>
    <button id="undo" class="statusLine button" disabled="disabled">Undo Last</button>

    <br class="brnodisplay"/>
    <label class="statusLine lblPuzzleNo" for="puzzleNo" style="font-weight:bold; left:50px;">Puzzle #: </label>
    <input id="puzzleNo" class="statusLine" style="left:50px; width:80px;" title="Enter a number and hit {Enter} to select a specific puzzle"></input>
    <span class="statusLine" id="puzzledate"></span>

    <!-- "Stats icon" -->
    <a id="statsParent" class="menuicon" style="right:60px;" onclick="showStats()">
        <i id="statsParent" class="fa fa-line-chart"></i>
        <div id="stats" class="menuContent menuText" style="width:300px;">
            <h1>Daily FlipIT Stats</h1>
            <table>
                <tr><td class="menuLabel">Played</td>        <td class="menuData" id="statsPlayed">0</td></tr>
                <tr><td class="menuLabel">Solved</td>        <td class="menuData" id="statsSolved">0</td></tr>
                <tr><td class="menuLabel">Win %</td>         <td class="menuData" id="statsWinPct">0%</td></tr>
                <tr><td class="menuLabel">Current Streak</td><td class="menuData" id="statsStreak">0</td></tr>
                <tr><td class="menuLabel">Max Streak</td>    <td class="menuData" id="statsMaxStreak">0</td></tr>
            </table>
        </div>
    </a>
    
    <!-- "Help icon" -->
    <a id="helpParent" class="menuicon" style="right:30px;" onclick="showHelp()">
        <i id="helpParent" class="fa fa-question-circle"></i>
        <div id="help" class="menuContent menuText">
            <h1>FlipIt</h1>
            <p style="color:darkred; text-align:center; margin-top:-6px;">Solve in 3 moves</p>
            <p>The objective is to get the puzzle to look like this:<br/>
            <canvas id="objective" class="targetImage">Your browser does not support the HTML5 canvas tag.</canvas>
            </p>
            <p>Click on a circle to flip its color and the color of all adjacent circles.
               This includes circles at the diagonals.
            </p>
            <p>All puzzles can be solved in 3 or fewer moves.
            </p>
            <p>You can choose between today's puzzle
               and unlimited random puzzles.  You can also select a puzzle by its number.  This allows
               you to solve the same puzzle as your friends.
            </p>
            <p>For the puzzle published in the August 2023 Mensa Bulletin, enter puzzle #48449.
            </p>
            <p style="color:black; text-align:center; font-size:15px;">Another fine HaxWare product<br/>
               By Evan A. Barr<br/>flipit at barr.rocks
            </p>
        </div>
    </a>
    
    <!-- "Hamburger menu" / "Bar icon" to toggle the navigation links -->
    <a id="topMenuParent" class="menuicon" onclick="showMenu()">
        <i id="topMenuParent" class="fa fa-bars"></i>
        <div id="topMenu" class="menuContent">
            <button id="target" class="menuItem" onclick="btnTarget()">Show Target</button>
            <button id="random" class="menuItem" onclick="btnRandom()">Random Puzzle</button>
            <button id="todays" class="menuItem" onclick="btnTodaysPuzzle()">Today's Puzzle</button>        

            <!-- <hr/>
            <input type="checkbox" id="diagonals" class="menuItem" checked>
            <label for="diagonals" class="menuItem menuText">Include Diagonals</label> -->
        </div>
    </a>
    
    <br/>
    <canvas id="myCanvas">Your browser does not support the HTML5 canvas tag.</canvas>     
</div>

<span id="isblocked" class="bottomAdbar" style="display:none;"></span>
<span id="bottomAdbar" class="bottomAdbar">
    <!-- Google AdSense - adunit  -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0549784498739741" crossorigin="anonymous" onerror="HasAdblocker()"></script>
    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    <ins class="adsbygoogle"
        style="display:block; height:100px; width:inherit;"
        data-ad-client="ca-pub-0549784498739741"
        data-ad-slot="7372507658"
        data-ad-format="rectangle, horizontal">
    </ins>
</span>
</div><!-- topDiv -->
    

<script>
// Info about original magic square puzzle (1978)
// https://clickamericana.com/toys-and-games/vintage-merlin-electronic-wizard-game-toy-console
"use strict";

//preventAdSenseHeightChange("topDiv");
preventAdSenseHeightChange("bottomAdbar");


// Globals
const mBorderLeft = 10, mBorderRight=10, mBorderTop = 80, mBorderBottom = 110;  // left and top must match the actual position for canvas element from html above.
const helpMenuWidth = 190;  // The width available to the "target" image displayed in the help menu.
const mMinWidth = 287;  // Canvas minimum width to prevent toolbar from getting messy.
const testPattern = [1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,1];
const mTargetPattern = [1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1];
const mTargetPuzzleNo = patternToNumber(mTargetPattern);

const colorBackground = "white", colorForground = "black", colorClicked = "lightcyan";  //greenyellow

const neverPlayed = "1900-01-01";
var mTodayDateText = "", mTodayPuzzleDate = neverPlayed, isDaily = false;
const persistName = "eb-flipit-stats";
var persist = {
    currentStreak: 0,
    maxStreak: 0,
    dailyGamesPlayed: 0,
    dailyGamesWon: 0,
    LastWinDate: neverPlayed,
    LastPlayDate: neverPlayed
};   // Win date and play date refer to daily game

var mBoxWidth = 0, mRadius = 0;

const mlblMoves = document.getElementById("moves");
var mMoves = 0, mIncludeDiagonals = true;
var mLastX = 0, mLastY = 0;

const minpPuzzleNo = document.getElementById("puzzleNo");
const mCanvas = document.getElementById("myCanvas");
const mContext = mCanvas.getContext("2d");
mContext.lineWidth = 1;
mContext.fillStyle = colorForground;

var mInitialized = false;

var mCircleArray;
var mCurrentPattern;


mCanvas.left = mBorderLeft;
mCanvas.top = mBorderTop;


drawObjective(document.getElementById("objective"), mTargetPattern, helpMenuWidth)
//loadPersist();   // Now done in btnTodaysPuzzle()

var mStartPattern = testPattern;
//drawCanvas(mStartPattern);   // Replaced with below
btnTodaysPuzzle(true);   // Always start with the daily puzzle.



// ------------------------
// Events
//
// Canvas Mouse-click event
mCanvas.addEventListener("mousedown", function(e) {
    const [x, y] = getMousePosition(mCanvas, e);
    hideAllMenus();
    //addMove();
    flipCircles(Math.floor(x/mBoxWidth), Math.floor(y/mBoxWidth), true);

    // If solved
    if (mTargetPuzzleNo == patternToNumber(mCurrentPattern)) { 
        blinkCircles();

        // Only update stats if we didn't already solve today's puzzle
        const daysSinceLastWin = isDaily ? dateDiff(persist.LastWinDate, mTodayPuzzleDate): 0;
        if (daysSinceLastWin > 0) {
            persist.dailyGamesWon++;
            persist.LastWinDate = mTodayPuzzleDate;

            // if (daysSinceLastWin == 1) {  // Now handled by btnTodaysPuzzle() which loads the stats
                persist.currentStreak++;
            // } else {
            //     persist.currentStreak = 1;
            // }
            if (persist.currentStreak > persist.maxStreak) {persist.maxStreak = persist.currentStreak;}

            const winPct = Math.round((100 * (persist.dailyGamesWon / persist.dailyGamesPlayed)) || 0).toString() + "%";
            document.getElementById("statsPlayed").innerText = persist.dailyGamesPlayed;
            document.getElementById("statsSolved").innerText = persist.dailyGamesWon;
            document.getElementById("statsWinPct").innerText = winPct;
            document.getElementById("statsStreak").innerText = persist.currentStreak;
            document.getElementById("statsMaxStreak").innerText = persist.maxStreak;

            updatePersisted();
        }
    }
});


// Reset button event
document.getElementById("reset").addEventListener("click", function(e) {
    resetCircles(mStartPattern);
});


// Undo button event
document.getElementById("undo").addEventListener("click", function(e) {
    Undo(e.target);
});


// puzzle number change event
document.getElementById("puzzleNo").addEventListener("change", function(e) {
    mStartPattern = numberToPattern(e.target.value);
    resetCircles(mStartPattern);
    e.target.blur();
});


// diagonals choice change event
document.getElementById("diagonals").addEventListener("change", function(e) {
    mIncludeDiagonals = e.target.checked;
});



// ------------------------
// Menu functions
//
function Undo(undoButton) {
    //subtractMove();
    flipCircles(mLastX, mLastY, true);
    undoButton.disabled = "disabled";
}



function btnTarget() {
    // Show the target pattern
    mStartPattern = mTargetPattern;
    resetCircles(mTargetPattern);
}


function btnRandom() {
    // Starting with the target solution, click 3 random circles to get a randum starting position
    mStartPattern = randomStart(mTargetPattern);
    resetCircles(mStartPattern);
}


function btnTodaysPuzzle(init) {
    // Uses today's date to generate a new starting puzzle
    if (typeof init === 'undefined') {init = false;}

    mStartPattern = todaysStart(mTargetPattern);   // Also calls function that sets mTodayPuzzleDate and mTodayDateText.

    if (init === true) {
        drawCanvas(mStartPattern);
    } else {
        resetCircles(mStartPattern);
    }

    
    // must be after resetCircles()
    document.getElementById("puzzledate").innerText = "Puzzle for " + mTodayDateText;
    isDaily = true;

    // If not already played today, update dailyGamesPlayed stat
    loadPersist();
    const daysSinceLastPlay = dateDiff(mTodayPuzzleDate, persist.LastPlayDate);
    const daysSinceLastWin = dateDiff(mTodayPuzzleDate, persist.LastWinDate);
    if (daysSinceLastPlay > 0) {
        persist.dailyGamesPlayed++;
        persist.LastPlayDate = mTodayPuzzleDate;

        // If it's been more than a day since playing or winning, reset streak
        if (daysSinceLastWin > 1) {
            persist.currentStreak = 0;
        }

        updatePersisted();
    }
}


function numberToPattern(number) {
    let bits = (n,b=32) => [...Array(b)].map((x,i)=>(n>>i)&1);
    let Bitarr = bits(number,16);
    return Bitarr;
}
function patternToNumber(pattern) {
    const binaryString = pattern.slice().reverse().join("");
    return parseInt(binaryString, 2);
}



// ------------------------
// Page functions
//
function resize() {
    drawCanvas(undefined, false)
}


function pageClick(e) {
    const evtobj = e || window.event;
    let id = evtobj.target.id;
    if (id.endsWith("Parent")) {id = id.substring(0, id.length - 6);}
    hideAllMenus(id);
}


function keyDown(e) {
    var evtobj = window.event? event : e
    if (evtobj.keyCode == 90 && evtobj.ctrlKey) {
        var btn = document.getElementById("undo");
        if (btn.disabled != true) {Undo(btn);}
    }
}


function showMenu() {showHiddenElement("topMenu");}
function showHelp() {showHiddenElement("help")}
function showStats() {showHiddenElement("stats")}
function showHiddenElement(elementId, forceHide) {
	// Set forceHide = true to not show element if it is already hidden
    if (typeof forceHide === 'undefined') {forceHide = false;}

    var x = document.getElementById(elementId);
    if (x.style.display === "block") {
        x.style.display = "none";
    } else if (forceHide === false) {
        x.style.display = "block";
    }
}
function hideAllMenus(currentId) {
    if (typeof currentId === 'undefined') {currentId = "";}

    // Close all menus except the one that was clicked
    if (currentId != "topMenu") showHiddenElement("topMenu", true);
    if (currentId != "help") showHiddenElement("help", true);
    if (currentId != "stats") showHiddenElement("stats", true);
}



// ------------------------
// Canvas functions
//
function drawCanvas(pattern, initialize) {
    const circlePadding = .25;
    if (typeof initialize === 'undefined') {initialize = true;}

    // Set the canvas size to fill the entire window (minus the canvas border)
    let viewWidth = window.innerWidth - (mBorderLeft + mBorderRight);
    let viewHeight = window.innerHeight - (mBorderTop + mBorderBottom);


    // Set canvas to be a square shape
    if (viewHeight < viewWidth) {
        viewWidth = viewHeight;
    //} else if (viewWidth < viewHeight) {
    //    viewHeight = viewWidth;
    }
    if (viewWidth < mMinWidth) {viewWidth = mMinWidth;}
    mCanvas.height = viewWidth;
    mCanvas.width = viewWidth;
    try {
        let adbar = document.getElementById("bottomAdbar");
        adbar.style.width = viewWidth + "px";
        adbar.style.top = mCanvas.top + viewWidth + 17 + "px";

        adbar = document.getElementById("isblocked");
        adbar.style.width = viewWidth + "px";
        adbar.style.top = mCanvas.top + viewWidth + 17 + "px";
    } catch(err) {
        console.log(err.message);
    }

    if (initialize === false) {
        mContext.clearRect(0, 0, viewWidth, viewWidth);
    }


    // Draw a 4 x 4 grid that fills the window
    mBoxWidth = Math.floor(viewWidth / 4);  // Width of one cell
    mRadius = (mBoxWidth - circlePadding * mBoxWidth) / 2;
    drawGrid(mContext, 4, 4, mBoxWidth);


    // Draw circles
    if (initialize === true) {
        mCircleArray = [];
        initCircles(pattern);
        mCurrentPattern = pattern.slice();
    } else {
        mCircleArray.forEach(drawCircle);
    }
}
function drawObjective(canvas, pattern, width) {
    canvas.width = width;
    canvas.height = width;

    // Draw a 4 x 4 grid that fills the window
    const boxWidth = width / 4;  // Width of one cell
    const context = canvas.getContext("2d");
    drawGrid(context, 4, 4, boxWidth);

    // Draw circles
    let circleArray = [];
    var pIndex = 0;
    for (let y=0; y<4; y++) {
        for (let x=0; x<4; x++) {
            circleArray.push(new Circle(x, y, pattern[pIndex]));
            pIndex++;
        }
    }

    const radius = (boxWidth - .25 * boxWidth) / 2;
    const params = {isBlink:false, boxWidth:boxWidth, radius:radius, context:context};
    circleArray.forEach(drawCircle, params);
}


function drawGrid(context, columns, rows, boxWidth,   lineWidth, color) {
	if (typeof lineWidth === 'undefined') {lineWidth = 1;}
	if (typeof color === 'undefined') {color = colorForground;}

	context.beginPath();
	context.lineWidth=lineWidth;
	context.strokeStyle=color;

	// Draw vertical lines
    let lineLength = boxWidth * rows;
    for (let i = 0; i <= columns; i++) {
		context.moveTo(i * boxWidth, 0);
		context.lineTo(i * boxWidth, lineLength);
	}

	// Draw horizontal lines
	lineLength = boxWidth * columns;
	for (let i = 0; i <= rows; i++) {
		context.moveTo(0, i * boxWidth);
		context.lineTo(lineLength, i * boxWidth);
	}

	context.stroke();
}


function getMousePosition(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    let x = event.clientX - rect.left;
    let y = event.clientY - rect.top;
    return [x, y];
}


function addMove() {
    mMoves++;
    mlblMoves.innerText = mMoves;
}
function subtractMove() {
    mMoves--;
    mlblMoves.innerText = mMoves;
}


function Circle(x,y,isFilled,clicked) {
    this.boxX = x;
    this.boxY = y;
    this.isFilled = isFilled;
    if (typeof clicked === 'undefined') {clicked = false;}
    this.clicked = clicked;
}


function drawCircle(o) {
	let isBlink = false, boxWidth = mBoxWidth, radius = mRadius, context = mContext;
    if (typeof this != 'undefined') {
        if (typeof this.isBlink != 'undefined') {isBlink = this.isBlink;}
        if (typeof this.boxWidth != 'undefined') {boxWidth = this.boxWidth;}
        if (typeof this.radius != 'undefined') {radius = this.radius;}
        if (typeof this.context != 'undefined') {context = this.context;}
    }

    const circleX = o.boxX * boxWidth + boxWidth / 2
    const circleY = o.boxY * boxWidth + boxWidth / 2

    context.beginPath();
    context.arc(circleX, circleY, radius, 0, Math.PI*2, true);
    context.closePath();

    let isFilled = o.isFilled;
    if (isBlink==true) {isFilled = 1 - isFilled;}

    if (isFilled === 1) {
        context.fill();
    } else {
        if (mInitialized===true) {
            context.fillStyle = colorBackground;
            context.fill();
            context.fillStyle = colorForground;
        }
        context.stroke();
    }
}


function clickCircle(o) {
    // Set or unset a highlighted background for this circle's square.
    const border = 1;

    if (o.clicked === true) {
        subtractMove();
        o.clicked = false;
        mContext.fillStyle = colorBackground;
    } else {
        addMove();
        o.clicked = true;
        mContext.fillStyle = colorClicked;
    }

    const boxX = o.boxX * mBoxWidth + border;
    const boxY = o.boxY * mBoxWidth + border;
    const width = mBoxWidth - border - 1;
    mContext.fillRect(boxX, boxY, width, width);
    mContext.fillStyle = colorForground;
}


function initCircles(pattern) {
    resetCircles(pattern);
    mInitialized = true;
}
function resetCircles(pattern) {
    var pIndex = 0;
    for (let y=0; y<4; y++) {
        for (let x=0; x<4; x++) {
            if (mInitialized===true) {
                let circle = mCircleArray[y * 4 + x];
                circle.isFilled = pattern[pIndex];
                if (circle.clicked === true) {clickCircle(circle);}
            } else {
                mCircleArray.push(new Circle(x, y, pattern[pIndex]));
            }
            pIndex++;
        }
    }

    mCircleArray.forEach(drawCircle);
    minpPuzzleNo.value = patternToNumber(pattern);
    mCurrentPattern = pattern.slice();

    mMoves = 0;    // Must be after clickCircle()
    mlblMoves.innerText = 0;
    document.getElementById("puzzledate").innerText = "";
    isDaily = false;

    const btnUndo = document.getElementById("undo");
    btnUndo.disabled = "disabled";
}
function blinkCircles() {
    const params = {isBlink:true};

    mCircleArray.forEach(drawCircle, params);
    setTimeout(function() {mCircleArray.forEach(drawCircle);}, 50);
    setTimeout(function() {mCircleArray.forEach(drawCircle, params);}, 100);
    setTimeout(function() {mCircleArray.forEach(drawCircle);}, 150);
}

function flipCircles(x, y, isClick) {
	if (typeof isClick === 'undefined') {isClick = false;}

    const index = y * 4 + x;
    if (isClick === true) {clickCircle(mCircleArray[index], index);}
    flipOneCircle(mCircleArray[index], index);


    // left
    if (x > 0) {flipOneCircle(mCircleArray[index-1], index-1);}

    // right
    if (x < 3) {flipOneCircle(mCircleArray[index+1], index+1);}

    // above
    if (y > 0) {
        flipOneCircle(mCircleArray[index-4], index-4);

        if (mIncludeDiagonals===true) {
            // above left
            if (x > 0) {flipOneCircle(mCircleArray[index-5], index-5);}

            // above right
            if (x < 3) {flipOneCircle(mCircleArray[index-3], index-3);}
        }
    }

    // below
    if (y < 3) {
        flipOneCircle(mCircleArray[index+4], index+4);

        if (mIncludeDiagonals===true) {
            // below left
            if (x > 0) {flipOneCircle(mCircleArray[index+3], index+3);}

            // below right
            if (x < 3) {flipOneCircle(mCircleArray[index+5], index+5);}
        }
    }


    // Enable undo
    document.getElementById("undo").disabled = "";
    mLastX = x;
    mLastY = y;
}

function flipOneCircle(oCircle, index) {
    oCircle.isFilled = 1 - oCircle.isFilled;
    drawCircle(oCircle);
    
    flipOnebit(mCurrentPattern, index);
}
function flipOnebit(pattern, index) {
    pattern[index] = 1 - pattern[index];
}


function randomStart(solution) {return createPuzzle(solution,false);}
function todaysStart(solution) {return createPuzzle(solution,true);}
function createPuzzle(solution, useToday) {
    // If useToday=true, the UTC date is used to generate a seed for the 
    // psudo random number generater so that the same date always gives
    // the same sequence of random numbers no mater your timezone.
    var pattern = solution.slice();
    var rLast = [-1, -1, -1], r = -1;

    if (useToday === true) {
        const seed128 = cyrb128(getSeedFromDate());
        var rand = sfc32(seed128[0], seed128[1], seed128[2], seed128[3]);
    }

    for (let i=0; i<3; i++) {
        while (rLast.includes(r) === true) {
            if (useToday === true) {
                r = rand();
            } else {
                r = Math.random();
            }
            r = Math.floor(r * 16);
        }
        rLast[i] = r;
        flipOnebit(pattern, r);

        // Affect other circles
        const x = r % 4;  // r mod 4 = (0 - 3)
        const y = Math.floor(r/4);  // = (0 - 3)
        //alert("r=" + r.toString() + ", x=" + x.toString() + ", y=" + y.toString())

        // Left
        if (x>0) {flipOnebit(pattern, r-1);
;}


        // Right
        if (x<3) {flipOnebit(pattern, r+1);}


        // Above
        if (y > 0) {
            flipOnebit(pattern, r-4);
            if (mIncludeDiagonals===true) {
                // Above left
                if (x>0) {flipOnebit(pattern, r-5);}
                // Above right
                if (x<3) {flipOnebit(pattern, r-3);}
            }
        }


        // Below
        if (y < 3) {
            flipOnebit(pattern, r+4);
            if (mIncludeDiagonals===true) {
                // Below left
                if (x>0) {flipOnebit(pattern, r+3);}
                // Below right
                if (x<3) {flipOnebit(pattern, r+5);}
            }
        }        
    }  //for


    return pattern;
}


// ------------------------
// Seedable randum number generation
//
// To use:
//    const seed128 = cyrb128(getSeedFromDate());
//    var rand = sfc32(seed128[0], seed128[1], seed128[2], seed128[3]);
//    let r = rand();

function cyrb128(str) {
    // hash function returns array of 4 32bit strings.

    let h1 = 1779033703, h2 = 3144134277,
        h3 = 1013904242, h4 = 2773480762;
    for (let i = 0, k; i < str.length; i++) {
        k = str.charCodeAt(i);
        h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
        h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
        h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
        h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
    }
    h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
    h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
    h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
    h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
    h1 ^= (h2 ^ h3 ^ h4), h2 ^= h1, h3 ^= h1, h4 ^= h1;
    return [h1>>>0, h2>>>0, h3>>>0, h4>>>0];
}
function sfc32(a, b, c, d) {
    // Returned function generates a psudo-random number based on a 128 bit seed (that has been separated into 4 32bit values).
    return function() {
      a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
      var t = (a + b) | 0;
      a = b ^ b >>> 9;
      b = c + (c << 3) | 0;
      c = (c << 21 | c >>> 11);
      d = d + 1 | 0;
      t = t + d | 0;
      c = c + t | 0;
      return (t >>> 0) / 4294967296;
    }
}
function getSeedFromDate() {
    //const weekdays = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    //const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    const weekdays = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    const months = ["January","February","March","April","May","June","July","August","September","October","November","December"];
    const now = new Date();

    const year = now.getUTCFullYear().toString();
    const nMonth = now.getUTCMonth();
    const month = months[nMonth];
    const nDay = now.getUTCDate();
    const day = (nDay + 9).toString();  // add 9 to guarantee a 2 digit result.
    const weekday = weekdays[now.getUTCDay()];

    mTodayDateText = weekday + " " + month + " " + nDay.toString() + ", " + year;
    mTodayPuzzleDate = year + "-" + nMonth.toString() + "-" + nDay.toString();
    return day + weekday.substr(0,3) + month.substr(0,3) + year;  // order selected with values changing the most at the beginning.
}



// ------------------------
// data functions
//
function dateDiff(utcdate1, utcdate2) {
    // Don't need to deal with daylight savings day if dates are already in UTC.
    const millisecondsPerDay = 1000 * 60 * 60 * 24;
    const date1 = new Date(utcdate1);
    const date2 = new Date(utcdate2);
    const diffTime = Math.abs(date2 - date1);
    const diffDays = Math.ceil(diffTime / millisecondsPerDay); 
    return diffDays;
}


function loadPersist() {
    // Since the persisted data only refers to stats for the daily puzzle,
    // this function is called when the daily puzzle is loaded.  Further processing
    // is done by the loader since it has more information.

    //var data = window.localStorage.getItem(persistName) || JSON.stringify(persist);
    var data = window.localStorage.getItem(persistName);
    if (data) {
        persist = JSON.parse(data);
    }
    //localStorage.clear();

    const winPct = Math.round((100 * (persist.dailyGamesWon / persist.dailyGamesPlayed)) || 0).toString() + "%";
    document.getElementById("statsPlayed").innerText = persist.dailyGamesPlayed;
    document.getElementById("statsSolved").innerText = persist.dailyGamesWon;
    document.getElementById("statsWinPct").innerText = winPct;
    document.getElementById("statsStreak").innerText = persist.currentStreak;
    document.getElementById("statsMaxStreak").innerText = persist.maxStreak;
}


function updatePersisted(e) {
    window.localStorage.setItem(persistName, JSON.stringify(persist));
}


// ------------------------
// Ads
//
function HasAdblocker() {
    var e = document.getElementById('isblocked');
    e.innerText='If you use an adBlocker, please consider whitelisting this site.  This is my only ad.';
    e.style.display = "block";
    
    document.getElementById('bottomAdbar').style.display = "none";

    if (typeof gtag !== 'undefined') {
        gtag("event", "HasAdBlocker", "Yes")
    //  // Log an event in Universal Analytics but without affecting overall bounce rate
    //  ga('send', 'event', 'Adblock', 'Yes', {'nonInteraction': 1}); 
    //} else {
    }
}


function preventAdSenseHeightChange(elementId) {
    //const e = document.getElementById(elementId);

    waitForElement(elementId).then((e) => {
        const observer = new MutationObserver(function (mutations) {
            mutations.forEach(function(mutation) {
                if (typeof mutation.OldValue === 'undefined') {
                    e.style.height = "";
                } else {
                    e.style.height = mutation.OldValue;
                }
            })
        });
        const config = {
            attributes: true,
            attributeFilter: ['style'],
            attributeOldValue: true
        }
        observer.observe(e, config);
    }); //waitForElement
}


function waitForElement(elementId) {
    return new Promise(resolve => {
        if (document.getElementById(elementId)) {
            return resolve(document.getElementById(elementId));
        }

        const observer = new MutationObserver(mutations => {
            if (document.getElementById(elementId)) {
                observer.disconnect();
                resolve(document.getElementById(elementId));
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    });
}
</script> 

</body>
</html>
